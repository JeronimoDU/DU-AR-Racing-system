{"slots":{"0":{"name":"receiver","type":{"events":[],"methods":[]}},"1":{"name":"slot2","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"if message == \"syncstart\" and running == false then\n    chronoStartCode = system.getUtcTime() + 10\n    script.onStart()\nelse\nend\n\nsystem.print(\"SPEEDER chan/mess: \"..channel .. \" / \" ..message)\n\nif channel == tostring(player.getId()..\"R\") then\n    if message == \"upload\" and listening == false then\n        listening = true\n        emitter.send(tostring(player.getId())..\"S\",\"start upload\")\n        system.print(\"SPEEDER: starting download\")\n    elseif listening == true and message ~= \"upload\" and message ~= \"upload finished\" then\n        --system.print(\"SPEEDER: chunk received \"..message)\n        if previousUploadData ~= message then\n            uploadData = uploadData .. message\n            previousUploadData = uploadData\n            system.print(\"SPEEDER: chunk received \"..#uploadData)\n            \n        else\n            \n        end\n        emitter.send(tostring(player.getId())..\"S\",\"received\")\n        \n    elseif message == \"upload finished\" and listening == true then\n        system.print(\"SPEEDER final data: \"..#uploadData)\n        emitter.send(tostring(player.getId())..\"S\",\"end upload\")\n        local decodedData = deserialize(uploadData)\n        system.print(decodedData.circuitName)\n        system.print(decodedData.version)\n        --system.print(table.concat(decodedData.waypoints))\n        for i, v in ipairs(decodedData.waypoints) do \n            system.print(v)\n        end\n        local dbData = deserialize(DB.getStringValue(decodedData.circuitName))\n        if not dbData or dbData.version < decodedData.version then\n            system.print(\"Newer version of \"..decodedData.circuitName..\" dowloaded, erasing previous one\")\n            DB.setStringValue(decodedData.circuitName, uploadData)\n        end\n        --WP = convertWP(decodedData.waypoints)\n        listening = false\n        uploadData = \"\"\n        previousUploadData = nil\n        script.onStart()\n    end\nend","filter":{"args":[{"variable":"*"},{"variable":"*"}],"signature":"onReceived(channel,message)","slotKey":"0"},"key":"0"},{"code":"if initialised == false then\n    emitter.send(emitterChan,serialize({name = player.getName(), bestTime = tTime}))\nend","filter":{"args":[],"signature":"onPressed()","slotKey":"5"},"key":"1"},{"code":"--system.print(system.getUtcTime())\nscriptVersion = \"1.1 [FEB 11 2024]\"\n----------------------------------------------------------------------------------------------------\n-----------------------------------------------------------------------------------------------------\ncircuitName = \"testTrack\" --export: circuit name\nversion = 1.0 \nemitterChan = circuitName --emitter communication channel for leader board\nchronoStartCode = 1666537200 --race time code for synchronized start (starting date in seconds)\ntourEnd = 1 --laps total number\nsetWaypoint = true --export: set default DU waypoints display\nARWaypoints = true --export: enable or disable AR waypoints display\nARPath = true --export: enable or disable AR path display\nARPathLength = 3 --export: number of waypoints for path to display\nfpsCount = true --export: display fps count\ncrossHair = true --export: display crosshair and drift indicator\nscaleCurve = 1 --export: curve scale for waypoints display distance(the smaller the further waypoints will appear)\nwpHeight = 5 --export: height of the center of checkpoint above recorded position\nconstructMask = false --export: virtual bounding box mask covering up waypoints\nbBoxScale = {0.9,1,0.7,1,1,0.7} --export: scale of the bBox for the mask{x front, y front, z front, x back, y back, z back}\ndamageAR = false --export: AR dammage repport\ndamageRepportFontHeight = 100 --export: AR damage repport font size\nrecordingMode = false --activates admin mode for waypoints recording\nif recordingMode then circuitName = \"Recording Mode: \"..circuitName end\nautoRecording = false --ALT + F9\nautoRecordingdistance = 350\nrecordedWPPos = {}\nwpRadiusAtmo = 30 --checkpoints are considered as a sphere in meter (ATMO)\nwpRadiusSpace = 2000 --checkpoints are considered as a sphere in meter (SPACE)\nwpRadius = wpRadiusAtmo \n\n-- ALT + 9 = auto recording by distance\n-- ALT + 8 = remove last waypoint\n-- ALT + 7 = add custom waypoint on player pos\n-- ALT + 6 = repop 1st waypoint marker\n\n\n-- set here under a custom list of waypoints\nwpPos = {}\n\n\n\n\n--system.setWaypoint(wpPos[1],true)\nsounds = {start = {\"Race_start.mp3\",2.8},\n          checkpoint = {\"Race_checkpoint.mp3\",0.8},\n          finish = {\"Race_finish.mp3\",7}}\n\nrecoverStart = false\nupdate = false\n----------------------------------------------------------------------------------------------------\n-----------------------------------------------------------------------------------------------------\n\nsystem.print(\"Sync Board started\")\ncore = nil\nscreen = nil\nemitter = nil\nbutton = nil\nreceiver = nil\nDb = nil\nlocal function findConnectedSlots()\n    local slot = {}\n    for slotName in pairs(unit) do\n        slot = unit[slotName]\n         if type(slot)=='table' and unit[slotName].getClass ~= nil and slotName~='system' and slotName~='library' and slotName~='unit' and slotName~='export' then\n            --system.print(slot.getElementClass())\n            if slot.getClass() == \"CoreUnitDynamic\" then\n                core = slot\n                system.print(\"Core found\")\n            end\n            if slot.getClass() == \"ScreenUnit\" then\n                screen = slot\n                system.print(\"Screen found\")\n            end\n            if slot.getClass() == \"EmitterUnit\" then\n                emitter = slot\n                system.print(\"Emitter found\")\n            end    \n            if slot.getClass() == \"ManualButtonUnit\" then\n                button = slot\n                system.print(\"Button found\")\n            end\n            if slot.getClass() == \"ReceiverUnit\" then\n                receiver = slot\n                system.print(\"Receiver found\")\n            end\n            if slot.getClass() == \"DataBankUnit\" then\n                DB = slot\n                system.print(\"Databank found\")\n            end\n        end\n    end\nend\nfindConnectedSlots()\nif not core or not emitter or not receiver or not DB then system.print(\"Core/emitter/receiver/databank needs to be connected!\") unit.exit()end\n\nAtlas = require \"atlas\"\nHelios = {}\nfor k, v in pairs(Atlas[0]) do\n    Helios[k]={name = Atlas[0][k].name[1],\n                        center = Atlas[0][k].center,\n                        radius = Atlas[0][k].radius,\n                        id = Atlas[0][k].id,\n                        }\nend\nAtlas = nil\n\n--playerName = string.sub(player.getName(),1,8) -- shorter names string 8 letters\nplayerName = player.getName()\n\nfunction playSound(mp3)\n    system.playSound(sounds[mp3][1])\nend\n-----------Receiverchannel setup----------------\nreceiverChan = \"syncstart\" --export:Syncstart channel\nchannels = {receiverChan,tostring(player.getId())..\"R\"}\nif receiver then receiver.setChannelList(channels) end\n------------------------------------------------\n\nlocal cos, sin, max, min, sqrt, rad, match, toNum = math.cos, math.sin, math.max, math.min, math.sqrt, math.rad, string.match, tonumber\nlocal function convertToWorldCoordinates(posString)\n    local num        = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'\n    local posPattern = '::pos{' .. num .. ',' .. num .. ',' .. num .. ',' .. num ..  ',' .. num .. '}'\n    local systemId, bodyId, latitude, longitude, altitude = match(posString,posPattern)\n    systemId = toNum(systemId)\n    bodyId = toNum(bodyId)\n    latitude = toNum(latitude)\n    longitude = toNum(longitude)\n    altitude = toNum(altitude)+wpHeight\n    if toNum(bodyId) == 0 then\n        return latitude,longitude,altitude\n    end\n    latitude = 0.0174532925199 * max(min(latitude, 90), -90)\n    longitude = 0.0174532925199 * (longitude % 360)\n    local center, radius = Helios[bodyId].center, toNum(Helios[bodyId].radius)\n    local xproj = cos(latitude)\n    local px, py, pz = center[1]+(radius+altitude) * xproj*cos(longitude),\n    center[2]+(radius+altitude) * xproj*sin(longitude),\n    center[3]+(radius+altitude) * sin(latitude)\n    return px, py, pz\nend\n\nlocal convertWP = function(t) -- convert a table of pos\n    if type(t[1]) == \"string\" then \n        local newT = {}\n        local x,y,z = 0,0,0\n        for i, v in ipairs(t) do\n            x,y,z = convertToWorldCoordinates(v)\n            newT[i] = {x,y,z} \n        end\n        return newT\n     elseif type(t[1]) == \"table\" then\n        return t\n     end\nend\n\n\nelements = core.getElementIdList()\nallElements = {}\ndammagedElements = {}\nlocal ei = 0\nfor k, v in pairs(elements) do\n    local class = core.getElementDisplayNameById(v)\n    local data = system.getItem(core.getElementItemIdById(v))\n    ei = ei+1\n    allElements[ei] = {id = v, name = class,text = \"0\", health = core.getElementHitPointsById(v), maxHealth = core.getElementMaxHitPointsById(v), localPos = core.getElementPositionById(v), pos = {0,0,0}}\nend\n\nlocal bBoxSize = construct.getBoundingBoxSize()\nlocal bBx, bBy, bBz =  bBoxSize[1], bBoxSize[2], bBoxSize[3]\nlocal bBoxCenter = construct.getBoundingBoxCenter()\nlocal bBCx, bBCy, bBCz = bBoxCenter[1], bBoxCenter[2], bBoxCenter[3]\n\nlocalBb = {{bBCx-(bBx/2)*bBoxScale[1],bBCy+(bBy/2)*bBoxScale[2],bBCz+(bBz/2)*bBoxScale[3]},\n            {bBCx-(bBx/2)*bBoxScale[4],bBCy-(bBy/2)*bBoxScale[5],bBCz-(bBz/2)*bBoxScale[6]},\n            {bBCx+(bBx/2)*bBoxScale[4],bBCy-(bBy/2)*bBoxScale[5],bBCz-(bBz/2)*bBoxScale[6]},\n            {bBCx+(bBx/2)*bBoxScale[1],bBCy+(bBy/2)*bBoxScale[2],bBCz+(bBz/2)*bBoxScale[3]},\n            {bBCx-(bBx/2)*bBoxScale[1],bBCy+(bBy/2)*bBoxScale[2],bBCz+(bBz/2)*bBoxScale[3]}\n            }\nworldBb = {}\n\n\nWP = {}\n\nlistening = false\nuploadData = \"\"\npreviousUploadData = nil\n\nscript = {\n    onStart = function()\n        local dbKeys = DB.getKeyList()\n        system.print(\"--------------------------\")\n        system.print(\"Tracks found on Databank:\")\n        for k, v in pairs(dbKeys) do\n            system.print(\"- \"..v)\n        end\n        system.print(\"--------------------------\")\n        if uploadData == \"\" and listening == false then\n            local decodedData = deserialize(DB.getStringValue(circuitName))\n            if decodedData and decodedData.waypoints then\n                circuitName = decodedData.circuitName or \"No Name\"\n                version = decodedData.version or 1.0\n                wpRadius = decodedData.wpRadius or wpRadius\n                tourEnd = decodedData.tourEnd or tourEnd\n                wpPos = decodedData.waypoints\n                WP = convertWP(wpPos) -- convert wpPos strings into world coordinates\n                \n                --system.setWaypoint(\"::pos{0,0,\"..WP[1][1]..\",\"..WP[1][2]..\",\"..WP[1][3]..\"}\",true)\n                system.print(\"Databank circuit loaded: \"..circuitName)\n                system.print(\"Databank waypoints loaded: \"..#WP)\n                system.print(\"To change the circuit, change circuitName variable in external parameters!\")\n            else\n                if #recordedWPPos ~= 0 and recordingMode == true then\n                    WP = convertWP(recordedWPPos)\n                    system.setWaypoint(recordedWPPos[1],true)\n                    system.print(\"Custom reccorded waypoints loaded: \"..#WP)\n                elseif #WP ~= 0 then\n                    WP = convertWP(wpPos) -- convert wpPos strings into world coordinates\n                    system.setWaypoint(wpPos[1],true)\n                    system.print(\"Hardcoded waypoints loaded \"..#WP)\n                end\n            end\n        end\n        system.showScreen(1)\n        fps = 0\n        uCount = 0\n        fillAnim = 1\n        initialised = false\n        running = false\n        finnished = false\n        playerRecap = {}\n        playerRecap.chronoTours = {}\n        playerRecap.waypoint = 0\n        playerRecap.bestTour = 0\n        tTime = 99999\n        remainingWP = WP\n        local startDelay = chronoStartCode < system.getUtcTime() and system.getUtcTime() + chronoStartCode or chronoStartCode - system.getUtcTime()\n        --chronoStartCode = chronoStartCode - system.getUtcTime()\n        --system.print(chronoStartCode)\n        unit.setTimer(\"fps\",1)\n        unit.setTimer(\"startdelay\",startDelay)\n        system.setScreen(\"\")\n        --system.setWaypoint(wpPos[1],true)\n        system.print(\"Script initialised succesfully!\")\n        if setWaypoint == true then\n            unit.setTimer(\"WP\",0.01)\n        end\n        listening = false\n        --emitter.send(emitterChan,serialize({construct = {id = construct.getId(), name = construct.getName()}, player = {id = player.getId(), name = player.getName()}, totalTime = 0, lap = 1}))\n    end,\n\n    onStop = function()\n        system.print(\"Thank you for playing on \"..circuitName..\", see you soon!\")\n    end,\n\n    luaInput = function(text)\n        if text == \"reset race\" then\n            chronoStartCode = system.getUtcTime() + 10\n            script.onStart()\n        elseif string.sub(text,1,6)  == \"remove\" and #text > 7 then\n            if DB.hasKey(string.sub(text,8,-1)) then\n                DB.clearValue(string.sub(text,8,-1))\n                system.print(\"Track \"..string.sub(text,8,-1)..\" has been deleted\")\n            end\n        elseif string.sub(text,1,8)  == \"distance\" and #text > 9 then\n            local n = tonumber(string.sub(text,10,-1))\n            autoRecordingdistance = type(n) == \"number\" and n or autoRecordingdistance\n            system.print(\"Auto recording distance set to: \"..autoRecordingdistance)\n        elseif text == \"force start\" then\n            chronoStartCode = system.getUtcTime() + 10\n            script.onStart()\n        elseif text == \"reset recording\" then\n            recordedWPPos = {}\n        elseif text == \"print to screen\" then\n            local data = \"{\"\n            for i, v in ipairs(recordedWPPos) do\n                data = data ..'\"'.. v ..'\",'\n            end\n            data = data .. \"}\"\n            if screen ~= nil then \n                screen.setHTML(data)\n            end\n        elseif text == \"reset all\" then\n            DB.clear()\n            unit.exit()\n        end\n    end,\n}\nunit.setTimer(\"onStart\",0.5)\n\n\n","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"2"},{"code":"fps = uCount\nuCount = 0\nif finnished == true then\n    --system.print(serialize({name = playerName, bestTime = tTime}))\n    --playerRecap.bestTour\n    emitter.send(emitterChan,serialize({name = playerName, bestTTime = tTime, bestLap = playerRecap.bestTour, laps = tourEnd}))\nend\n\nlocal inspace = false\nif unit.getAtmosphereDensity() < 0.075 then\n    inspace = true\nend\n\nlocal altitude = core.getAltitude() \nif inspace == true and (altitude >= wpRadiusSpace+3000 or altitude == 0) then\n    wpRadius = wpRadiusSpace\nelse \n    wpRadius = wpRadiusAtmo\nend\n\nif finnished == false and recordingMode == false and running == true then\n\n    DB.setStringValue(\"activeRace\", serialize({\n        initialised = initialised,\n        running = running,\n        finished = finished,\n        playerRecap = playerRecap,\n        tTime = tTime,\n        remainingWP = playerRecap.waypoint,    \n        }))\n    --system.print(DB.getStringValue(\"activeRace\"))\n    --system.print(\"Saving race backup\")\nend\n","filter":{"args":[{"value":"fps"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"3"},{"code":"if recoverStart == false then\n    initialised = true\n    playerRecap.chronoTours[1] = {system.getUtcTime(),0}\n    playSound(\"start\")\n    unit.stopTimer(\"startdelay\")\nend","filter":{"args":[{"value":"startdelay"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"4"},{"code":"script.onStop()","filter":{"args":[],"signature":"onStop()","slotKey":"-1"},"key":"5"},{"code":"if waypointUp == true then\n    --system.print(\"waypoint up\")\n    system.setWaypoint(\"::pos{0,0,\"..remainingWP[1][1]..\",\"..remainingWP[1][2]..\",\"..remainingWP[1][3]..\"}\",true)\n    waypointUp = false\nend\n","filter":{"args":[{"value":"WP"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"6"},{"code":"script.onStart()\n--unit.setTimer(\"update\",1)\nupdate = true\nunit.stopTimer(\"onStart\")","filter":{"args":[{"value":"onStart"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"7"},{"code":"local format,cos, sin, max, min, sqrt, rad, match, toNum = string.format, math.cos, math.sin, math.max, math.min, math.sqrt, math.rad, string.match, tonumber\nlocal cWP = construct.getWorldPosition()\nlocal cWPx, cWPy, cWPz = cWP[1], cWP[2], cWP[3]\nlocal cWOU = construct.getWorldOrientationUp()\nlocal cWOUx, cWOUy, cWOUz = cWOU[1], cWOU[2], cWOU[3]\nlocal cWOF = construct.getWorldOrientationForward()\nlocal cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]\nlocal cWOR = construct.getWorldOrientationRight()\nlocal cWORx, cWORy, cWORz = cWOR[1], cWOR[2], cWOR[3]\n\nlocal function vectorLen(x,y,z)\n    return sqrt(x * x + y * y + z * z)\nend\n\nif initialised == true and recordingMode == false then\n    local function tableShift(tbl, amount)\n        local t = {}\n        local n = #tbl\n        local i\n        for k,v in ipairs(tbl) do\n            i = k + amount > 0 and k + amount or n\n            if i <= n then\n                t[i] = v\n            else\n                t[i-n] = v\n            end\n        end\n        return t\n    end\n    \n    local x,y,z = 0,0,0\n    local function local2World(vx,vy,vz)\n        x = vx * cWORx + vy * cWOFx + vz * cWOUx + cWPx\n        y = vx * cWORy + vy * cWOFy + vz * cWOUy + cWPy\n        z = vx * cWORz + vy * cWOFz + vz * cWOUz + cWPz\n        return x,y,z\n    end\n\n    local vx,vy,vz = 0,0,0\n    local health = 100\n    local dind = 0\n    dammagedElements = {}\n    for i, v in ipairs(allElements) do\n        health = (core.getElementHitPointsById(v.id)/v.maxHealth)*100 or 0\n        --system.print(health)\n        if health < 99.9 then\n            dind = dind + 1\n            dammagedElements[dind] = {}\n            vx,vy,vz = local2World(v.localPos[1], v.localPos[2], v.localPos[3])\n            dammagedElements[dind].pos = {vx,vy,vz}\n            dammagedElements[dind].text = format(\"%.1f\",health)\n        end\n    end\n\n    for i, v in ipairs(localBb) do\n        vx,vy,vz = local2World(v[1], v[2], v[3])\n        worldBb[i] = {vx,vy,vz}\n    end\n    \n    \n    local gAT = system.getUtcTime() --system.print(gAT)\n    local tl = #remainingWP\n    local ctn = #playerRecap.chronoTours\n    local chrono = 0\n    \n    local wpDist = vectorLen(remainingWP[1][1]-cWPx,remainingWP[1][2]-cWPy,remainingWP[1][3]-cWPz)\n    if wpDist < wpRadius then\n        playerRecap.waypoint = playerRecap.waypoint + 1 \n        playSound(\"checkpoint\")\n        if playerRecap.waypoint > tl then \n            if ctn + 1 > tourEnd then\n                playSound(\"finish\")\n                playerRecap.chronoTours[ctn][2] = gAT\n                playerRecap.waypoint = 0\n                initialised = false\n                running = false\n                finnished = true\n                tTime = gAT-playerRecap.chronoTours[1][1]--system.getUtcTime()-playerRecap.chronoTours[1][1]\n                if emitter then\n                    emitter.send(emitterChan,serialize({name = playerName, bestTime = tTime}))\n                end\n            else\n                playerRecap.waypoint = 1\n                playerRecap.chronoTours[ctn][2] = gAT\n                playerRecap.chronoTours[ctn+1] = {gAT,0}    \n            end\n        --emitter.send(emitterChan,serialize({construct = {id = construct.getId(), name = construct.getName()}, player = {id = player.getId(), name = player.getName()}, totalTime = system.getUtcTime()-playerRecap.chronoTours[1][1], lap = #playerRecap.chronoTours})) \n        end\n        waypointUp = true\n        --system.setWaypoint(wpPos[playerRecap.waypoint+1],true)\n        remainingWP = tableShift(remainingWP, -1)\n        --system.print(#remainingWP)\n    end\n\n    \n    local v2x,v2y,v2z = 0,0,0\n    for i, v in ipairs(remainingWP) do\n        vx,vy,vz = v[1], v[2], v[3]\n        if i == 1 then \n            wpDist = vectorLen(vx-cWPx,vy-cWPy,vz-cWPz)\n        else \n            if i < tl then\n                v2x,v2y,v2z = remainingWP[i+1][1], remainingWP[i+1][2], remainingWP[i+1][3]\n                wpDist = wpDist + vectorLen(vx-v2x,vy-v2y,vz-v2z)\n            else \n                v2x,v2y,v2z = remainingWP[1][1], remainingWP[1][2], remainingWP[1][3]\n                wpDist = wpDist + vectorLen(vx-v2x,vy-v2y,vz-v2z)\n            end\n        end\n        remainingWP[i].dist = wpDist or 0\n    end\n\n    --table.sort(WP, function(a,b)return a.dist<b.dist end) --v[2]-v[1]\n    local max = math.huge\n    local min = 0\n    for i, v in ipairs(playerRecap.chronoTours) do\n        min = v[2]-v[1]\n        if i ~= cpn and min < max then\n            playerRecap.bestTour = min\n            max = min\n        end\n    end\n    running = true\n        \nelse \n    if recordingMode == true then\n        local function convertToWorldCoordinates(posString)\n            local num        = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'\n            local posPattern = '::pos{' .. num .. ',' .. num .. ',' .. num .. ',' .. num ..  ',' .. num .. '}'\n            local systemId, bodyId, latitude, longitude, altitude = match(posString,posPattern)\n            systemId = toNum(systemId)\n            bodyId = toNum(bodyId)\n            latitude = toNum(latitude)\n            longitude = toNum(longitude)\n            altitude = toNum(altitude)\n            if toNum(bodyId) == 0 then\n                return latitude,longitude,altitude\n            end\n            latitude = 0.0174532925199 * max(min(latitude, 90), -90)\n            longitude = 0.0174532925199 * (longitude % 360)\n            local center, radius = Helios[bodyId].center, toNum(Helios[bodyId].radius)\n            local xproj = cos(latitude)\n            local px, py, pz = center[1]+(radius+altitude) * xproj*cos(longitude),\n            center[2]+(radius+altitude) * xproj*sin(longitude),\n            center[3]+(radius+altitude) * sin(latitude)\n            return px, py, pz\n        end\n\n        local convertWP = function(t) -- convert a table of pos\n            local newT = {}\n            local x,y,z = 0,0,0\n            for i, v in ipairs(t) do\n                x,y,z = convertToWorldCoordinates(v)\n                newT[i] = {x,y,z} \n            end\n            return newT\n        end\n\n        local rx, ry, rz = cWPx, cWPy, cWPz\n        if #recordedWPPos ~= 0 then rx, ry, rz = convertToWorldCoordinates(recordedWPPos[#recordedWPPos])end\n        \n        local lastDist = vectorLen(rx-cWPx, ry-cWPy, rz-cWPz)\n        \n        if autoRecording == true and lastDist > autoRecordingdistance then\n            recordedWPPos[#recordedWPPos+1] = system.getWaypointFromPlayerPos()\n            --system.setWaypoint(system.getWaypointFromPlayerPos(),true)\n            system.print(\"auto waypoint added\")\n        end\n        WP = convertWP(recordedWPPos)\n    else\n        running = false\n    end\nend\n\n--playerRecap = {}\n--playerRecap.chronoStart = system.getArkTime()\n--playerRecap.chronoTours = {system.getArkTime()}\n--playerRecap.waypoint = 0\n--playerRecap.bestTour = 0\n--remainingWP = WP","filter":{"args":[],"signature":"onFlush()","slotKey":"-4"},"key":"8"},{"code":"script.luaInput(text)","filter":{"args":[{"variable":"*"}],"signature":"onInputText(text)","slotKey":"-4"},"key":"9"},{"code":"if recordingMode == true then\n    autoRecording = not autoRecording\n    if autoRecording == true then\n        system.print(\"recording\")\n        recordedWPPos[#recordedWPPos+1] = system.getWaypointFromPlayerPos()\n        system.setWaypoint(system.getWaypointFromPlayerPos(),true)\n    elseif autoRecording == false then\n        system.print(\"stoped recording\")\n        local data = \"{\"\n        for i, v in ipairs(recordedWPPos) do\n            data = data ..'\"'.. v ..'\",'\n        end\n        data = data .. \"}\"\n        if screen ~= nil then \n            screen.setHTML(data)\n        end\n    end\nelseif recordingMode == false and finnished == true and emitter then\n    system.print(serialize({name = playerName, bestTime = tTime}))\n    emitter.send(emitterChan,serialize({name = playerName, bestTime = tTime}))\nelseif recordingMode == false and finnished == false and emitter then\n    chronoStartCode = system.getUtcTime() + 10\n    script.onStart()\n    --unit.setTimer(\"update\",0.01)\nend\n","filter":{"args":[{"value":"option9"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"10"},{"code":"if recordingMode == true then\n    system.print(\"last waypoint deleted\")\n    recordedWPPos[#recordedWPPos] = nil\n    --system.setWaypoint(recordedWPPos[#recordedWPPos],true)\nend","filter":{"args":[{"value":"option8"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"11"},{"code":"\nrecordedWPPos[#recordedWPPos+1] = system.getWaypointFromPlayerPos()\n--system.setWaypoint(system.getWaypointFromPlayerPos(),true)\nsystem.print(\"added custom waypoints: \"..#recordedWPPos)","filter":{"args":[{"value":"option7"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"12"},{"code":"if recordingMode == true then\n    system.setWaypoint(recordedWPPos[1],true)\n    system.print(\"recording\")\nend","filter":{"args":[{"value":"option6"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"13"},{"code":"if finnished == false and recordingMode == false and emitter then\n    \n    recoverStart = true\n    script.onStart()\n    unit.stopTimer(\"startdelay\")\n    \n    local decodeSave = deserialize(DB.getStringValue(\"activeRace\"))    \n    local function tableShift(tbl, amount)\n        local t = {}\n        local n = #tbl\n        local i\n        for k,v in ipairs(tbl) do\n            i = k + amount > 0 and k + amount or n\n            if i <= n then\n                t[i] = v\n                --system.print(i)\n            else\n                t[i-n] = v\n                --system.print(i-n)\n            end\n        end\n        return t\n    end\n    \n    remainingWP = WP\n    --system.print(\"decodeSave.remainingWP \"..decodeSave.remainingWP)\n    if decodeSave.remainingWP ~= 0 then --decodeSave.remainingWP < #WP then -- then\n        for i = decodeSave.remainingWP, 1, -1 do\n            remainingWP = tableShift(remainingWP, -1)\n            --system.print(\"Shift \"..i)\n        end\n    end\n    system.print(\"New remaining WP \"..#remainingWP)\n    \n    for i, v in ipairs(remainingWP) do\n        remainingWP[i].dist = 0\n    end\n\n    playerRecap = decodeSave.playerRecap\n    tTime = decodeSave.tTime\n    initialised = decodeSave.initialised\n    running = decodeSave.running\n    finished = decodeSave.finished\n    \n    --system.print(DB.getStringValue(\"activeRace\"))\n    recoverStart = false\n    waypointUp = true\n    playSound(\"start\")\n    --unit.setTimer(\"update\",0.01)\n    system.print(\"Race recovered to last save\")\nend\n    \n    \n    ","filter":{"args":[{"value":"option0"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"14"},{"code":"if update == true then\n    local sgt = system.getUtcTime()\n    local sqrt, tan, rad, format, concat, floor = math.sqrt, math.tan, math.rad, string.format, table.concat, math.floor\n    local sw = system.getScreenWidth()\n    local sh = system.getScreenHeight()\n    local vFov = system.getCameraVerticalFov()\n    local near = 0.1\n    local far = 100000000.0\n    local aspectRatio = sh/sw\n    local tanFov = 1.0/tan(rad(vFov)*0.5)\n    local field = -far/(far-near)\n    local af = aspectRatio*tanFov\n    local nq = near*field\n    \n    local camWP = system.getCameraWorldPos()\n    local camWPx, camWPy, camWPz = camWP[1], camWP[2], camWP[3]\n    local camWF = system.getCameraWorldForward()\n    local camWFx, camWFy, camWFz = camWF[1], camWF[2], camWF[3]\n    local camWR = system.getCameraWorldRight()\n    local camWRx, camWRy, camWRz = camWR[1], camWR[2], camWR[3]\n    local camWU = system.getCameraWorldUp()\n    local camWUx, camWUy, camWUz = camWU[1], camWU[2], camWU[3]\n    \n    local cWP = construct.getWorldPosition()\n    local cWPx, cWPy, cWPz = cWP[1], cWP[2], cWP[3]\n    local cWOU = construct.getWorldOrientationUp()\n    local cWOUx, cWOUy, cWOUz = cWOU[1], cWOU[2], cWOU[3]\n    local cWOF = construct.getWorldOrientationForward()\n    local cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]\n    local cWOR = construct.getWorldOrientationRight()\n    local cWORx, cWORy, cWORz = cWOR[1], cWOR[2], cWOR[3]\n    local mPP = player.getPosition()\n    local mPPx, mPPy = mPP[1], mPP[2]\n    local cAV = construct.getWorldVelocity()\n    local cAVx, cAVy, cAVz = cAV[1], cAV[2], cAV[3]\n    local xyzSpeedMPS = sqrt(cAVx^2+cAVy^2+cAVz^2)\n    \n    local posX, posY, posZ = 0, 0, 0\n    local vx, vy, vz = 0, 0, 0\n    local sx, sy, sz = 0, 0, 0\n    local sPX, sPY = 0\n    local dist = 0\n    \n    local function projection2D()\n        vx = posX * camWRx + posY * camWRy + posZ * camWRz\n        vy = posX * camWFx + posY * camWFy + posZ * camWFz\n        vz = posX * camWUx + posY * camWUy + posZ * camWUz\n        sx = (af * vx)/vy\n        sy = ( -tanFov * vz)/vy\n        sz = ( -field * vy + nq)/vy\n        sPX, sPY = (sx+1)*sw*0.5, (sy+1)*sh*0.5 -- screen pos X Y\n        dist = sqrt(posX*posX + posY*posY + posZ*posZ) or 0 -- distance from camera to pos\n    end\n    \n    local styles = [[\n    <style>\n    .markers {text-anchor: middle; font-family: Indoscreen; alignment-baseline: middle; fill: white;}\n    .counter {text-anchor: middle; font-family: Play; alignment-baseline: middle; fill: red;}\n    .hud {text-anchor: start; font-family: Indoscreen; alignment-baseline: middle; stroke-width: 2; fill: red;}\n    .repport {text-anchor: middle; font-family: Indoscreen; alignment-baseline: middle; fill: orange;}\n    .repportRed {text-anchor: middle; font-family: Indoscreen; alignment-baseline: middle; fill: red;}\n    </style>]]\n    \n    local mask = \"\"\n    if system.isFirstPerson() ~= 1 and constructMask == true then\n        mask = mask..[[<clipPath id=\"bBox\"><polyline points=\"0,0 ]]..sw..[[,0 ]]..sw..[[,]]..sh..[[ 0,]]..sh..[[ 0,0 ]]\n        for i, v in ipairs(worldBb) do\n            posX = v[1] - camWPx\n            posY = v[2] - camWPy\n            posZ = v[3] - camWPz\n            projection2D()\n            mask = mask .. format(\"%0.1f,%0.1f \",sPX,sPY)\n        end\n        mask = mask .. [[\"/></clipPath>]]\n    end\n        \n    local style = \"\"\n    local svgT = {}\n    local ind = 0\n    local text = \"\"\n    \n    if damageAR == true then\n        for i, v in ipairs(dammagedElements) do\n            style = \"repport\"\n            posX = v.pos[1] - camWPx\n            posY = v.pos[2] - camWPy\n            posZ = v.pos[3] - camWPz\n            projection2D()\n            if sz < 1 and sPX > 0 and sPX < sw and sPY > 0  and sPY < sh then\n                text = v.text\n                if tonumber(v.text) == 0 then style = \"repportRed\" text = v.name end\n                ind = ind +1\n                svgT[ind] = format([[<text x=\"%.1f\" y=\"%.1f\" class=\"%s\" font-size=\"%.1f\">%s%%</text>]], \n                    sPX,sPY,style,1 / dist * damageRepportFontHeight,text)\n            end\n        end\n    end\n    local ctn = #playerRecap.chronoTours or 0\n    local wpn = #remainingWP ~= 0 and #remainingWP or #WP\n    if running == true and recordingMode == false then\n        if ARPath == true then\n            --cWPx, cWPy, cWPz cWOFx, cWOFy, cWOFz\n            posX = cWPx+cWOFx*5 - camWPx\n            posY = cWPy+cWOFy*5 - camWPy\n            posZ = cWPz+cWOFz*5 - camWPz\n            projection2D()\n            ind = ind +1\n            svgT[ind] =  format([[<polyline fill=\"none\" stroke=\"yellow\" stroke-width=\"2\" stroke-opacity=\"0.5\" points=\"%.1f,%.1f ]], sPX, sPY)\n            for i=1, ARPathLength do\n                local nextWP = i < wpn and remainingWP[i] or WP[i]\n                posX = nextWP[1] - camWPx\n                posY = nextWP[2] - camWPy\n                posZ = nextWP[3] - camWPz\n                projection2D()\n                if sz < 1 and sPX > -sw and sPX < 2*sw and sPY > -sh  and sPY < 2*sh then\n                    ind = ind +1\n                    svgT[ind] =  format([[%.1f,%.1f ]], sPX, sPY)\n                end\n            end\n            ind = ind +1\n            svgT[ind] =  [[\"/>]]\n        end\n        if ARWaypoints == true then\n            fillAnim = fillAnim > 0.85 and fillAnim - 0.005 or 1\n            local sizeScale = 1\n            for i=wpn, 1, -1 do\n                local v = remainingWP[i]\n                posX = v[1] - camWPx\n                posY = v[2] - camWPy\n                posZ = v[3] - camWPz\n                projection2D()\n                v.dist = v.dist or 0\n                sizeScale = (-scaleCurve*0.0000015)*v.dist^2 + 1\n                sizeScale = sizeScale > 0 and sizeScale or 0\n                if sz < 1 and sPX > -sw and sPX < 2*sw and sPY > -sh  and sPY < 2*sh and sizeScale > 0 then\n                    local h = 1 / dist * wpRadius * 1000\n                    local fcolor = ctn == tourEnd and playerRecap.waypoint == wpn and i == 1 and \"orange\" or i == 1 and \"chartreuse\" or \"skyblue\"\n                    --if  then fcolor = \"gold\" end\n                    ind = ind +1\n                    svgT[ind] = format([[<style>\n                    .waypoint%s {text-anchor: middle; stroke: %s; stroke-width: %.1f}\n                    </style>]],\n                    i, \"GreenYellow\", 1 / dist * 200)\n                    ..format([[<radialGradient id=\"radial\" cx=\"%.1f\" cy=\"%.1f\" r=\"%.1f\"\n                    gradientUnits=\"userSpaceOnUse\">\n                    <stop  offset=\"%.2f\" style=\"stop-color:%s; stop-opacity:0.05\"/>\n                    <stop  offset=\"1\" style=\"stop-color:%s\"; stop-opacity:0/>\n                    </radialGradient>]],\n                    sPX, sPY,  h*sizeScale, fillAnim, \"black\", fcolor)\n                    ..format([[<circle cx=\"%.1f\" cy=\"%.1f\" r=\"%.1f\" class=\"%s\" fill=\"url(#radial)\" clip-path=\"url(#bBox)\"/>]], \n                    sPX, sPY,  h*sizeScale, \"waypoint\"..i)\n                    if fcolor == \"orange\" then break end\n                end\n            end\n        end\n    elseif recordingMode == true then\n        wpn = #WP\n        for i=wpn, 1, -1 do\n            local v = WP[i]\n            posX = v[1] - camWPx\n            posY = v[2] - camWPy\n            posZ = v[3] - camWPz\n            projection2D()\n            if sz < 1 and sPX > -sw and sPX < 2*sw and sPY > -sh  and sPY < 2*sh then\n                local h = 1 / dist * 2000\n                ind = ind + 1\n                svgT[ind] = format([[<text x=\"%.1f\" y=\"%.1f\" class=\"markers\" font-size=\"%.1f\" clip-path=\"url(#bBox)\">%s</text>]],\n                    sPX, sPY, h, i)\n            end\n            if i == wpn - 50 then break end\n        end\n    end\n    \n    \n    --SVG = SVG .. [[<text x=\"20\" y=\"20\" class=\"hud\" font-size=\"20\" >AR Ship Info - by Jeronimo 2022</text>]] \n    --SVG = SVG .. [[<text x=\"20\" y=\"40\" class=\"hud\" font-size=\"20\" >FPS: ]].. fps ..[[</text>]] \n    --SVG = SVG .. [[<text x=\"20\" y=\"60\" class=\"hud\" font-size=\"20\" >AR points displayed: ]].. ind ..[[</text>]]\n    \n    local function SecondsToClock(seconds)\n        local seconds = tonumber(seconds)\n        local miliSec = seconds - floor(seconds) \n        if seconds <= 0 then --or floor(seconds/3600) > 24 \n            return \"00min : 00sec\"\n        else\n            local hours = format(\"%02.f\", floor(seconds/3600))\n            local mins = format(\"%02.f\", floor(seconds/60 - (hours*60)))\n            local secs = format(\"%02.f\", floor(seconds - hours*3600 - mins *60))\n            return format(\"%.0fmin : %02.fsec : %03.fms\", hours*60+mins, secs, miliSec*1000)\n        end\n    end  \n    \n    local tSVG = {}\n    local tind = 0\n    local tLines = 5\n    local gAT = running == true and system.getUtcTime() or ctn ~= 0 and playerRecap.chronoTours[ctn][2] or system.getUtcTime()\n    \n    tind = tind +1\n    tSVG[tind] = \n    --width=16% \n    [[<table height=]].. 15/ctn+tLines ..[[% border=\"1\" cellpadding=\"5\">\n    <tr style=\"background-color:rgba(50,50,50, 0.7)\" >\n    <td height=]].. 100/ctn+tLines ..[[% width=100% align=\"left\" valign=\"center\" >\n    <p style=\"font-size: 1.25em; color:skyblue; font-family:Play; opacity: 1\">\n    ]].. circuitName..\" v\"..version..[[\n    </p>\n    </td>\n    </tr>]]\n    \n    tind = tind +1\n    tSVG[tind] = [[\n    <tr style=\"background-color:rgba(50,50,50, 0.5)\">\n    <td height=]].. 100/ctn+tLines ..[[% width=100% align=\"left\" valign=\"center\">\n    <p style=\"font-size: 1em; color:white; font-family:Play; \">\n    Waypoint: ]].. playerRecap.waypoint..\"/\".. wpn ..[[\n    </p>\n    </td>\n    </tr>]]\n    \n    tind = tind +1\n    tSVG[tind] = [[\n    <tr style=\"background-color:rgba(50,50,50, 0.7)\">\n    <td height=]].. 100/ctn+tLines ..[[% width=100% align=\"left\" valign=\"center\">\n    <p style=\"font-size: 1em; color:white; font-family:Play; \">\n    Lap: ]].. ctn ..\"/\".. tourEnd ..[[\n    </p>\n    </td>\n    </tr>]]\n    \n    tind = tind +1\n    tSVG[tind] = [[\n    <tr style=\"background-color:rgba(50,50,50, 0.5)\">\n    <td height=]].. 100/ctn+tLines ..[[% width=100% align=\"left\" valign=\"center\">\n    <p style=\"font-size: 1em; color:white; font-family:Play; \">\n    Best Time: ]].. SecondsToClock(playerRecap.bestTour) ..[[\n    </p>\n    </td>\n    </tr>]]\n    \n    if ctn ~= 0 then\n        tind = tind +1\n        tSVG[tind] = [[\n        <tr style=\"background-color:rgba(50,50,50, 0.7)\">\n        <td height=]].. 100/ctn+tLines ..[[% width=100% align=\"left\" valign=\"center\">\n        <p style=\"font-size: 1em; color:white; font-family:Play; \">\n        Total Time: ]].. SecondsToClock(gAT-playerRecap.chronoTours[1][1]) ..[[\n        </p>\n        </td>\n        </tr>]]\n    end\n    \n    for i, v in ipairs(playerRecap.chronoTours) do\n        local timeText = i < ctn and SecondsToClock(v[2]-v[1]) or SecondsToClock(gAT-v[1]) \n        tind = tind +1\n        tSVG[tind] = [[\n        <tr style=\"background-color:rgba(50,50,50, 0.5)\">\n        <td height=]].. 100/ctn+tLines ..[[% width=100% align=\"left\" valign=\"center\">\n        <p style=\"font-size: 1.1em; color:red; font-family:Play;\">\n        Lap time ]].. i ..[[: ]].. timeText ..[[\n        </p>\n        </td>\n        </tr>]]     \n    end\n    \n    tind = tind +1\n    tSVG[tind] = \"</table>\"\n    \n    gAT = system.getUtcTime()\n    if chronoStartCode - gAT > 0 then\n        ind = ind +1\n        svgT[ind] = format([[<text x=\"%.1f\" y=\"%.1f\" class=\"counter\" font-size=\"3em\">%s</text>]],\n                    sw/2, sh/3, SecondsToClock(chronoStartCode - gAT))\n        ind = ind +1\n        svgT[ind] = format([[<text x=\"%.1f\" y=\"%.1f\" class=\"counter\" font-size=\"3em\">%s starts in:</text>]],\n                    sw/2, sh/3-50, circuitName)\n        --system.print(chronoStartCode - gAT)\n    end  \n    \n    if crossHair == true then\n        posX = cWOFx*1000000000000 - camWPx\n        posY = cWOFy*1000000000000 - camWPy\n        posZ = cWOFz*1000000000000 - camWPz\n        projection2D()\n        ind = ind + 1\n        svgT[ind] = format([[<text x=\"%.1f\" y=\"%.1f\" font-size=\"20\" text-anchor=\"middle\" font-family=\"play\" alignment-baseline=\"middle\" fill=\"white\">╬</text>]],\n            sPX, sPY)\n        if xyzSpeedMPS > 5 then\n           posX = (cAVx)*1000000000000 - camWPx\n            posY = (cAVy)*1000000000000 - camWPy\n            posZ = (cAVz)*1000000000000 - camWPz\n            projection2D()\n        end\n        ind = ind + 1\n        svgT[ind] = format([[<text x=\"%.1f\" y=\"%.1f\" font-size=\"20\" text-anchor=\"middle\" font-family=\"play\" alignment-baseline=\"middle\" fill=\"chartreuse\">┼</text>]],\n        sPX, sPY)\n    end\n    --.hud {text-anchor: start;font-family: Play;alignment-baseline: middle;stroke-width: 2;\n    --        fill: white; stroke-width: 15px; stroke: black; paint-order: stroke;}\n    ind = ind + 1\n    svgT[ind] = [[<text x=\"20\" y=\"99.5%\" fill=\"skyblue\" font-size=\"14\" font-family=\"Play\" stroke-width=\"2px\" stroke=\"gray\" >DU AR Raching v]]..scriptVersion..[[</text>]]\n    \n    if recordingMode == true then\n    \n    ind = ind + 1\n    svgT[ind] = [[<text x=\"20\" y=\"40\" fill=\"skyblue\" font-size=\"20\" font-family=\"Play\" stroke-width=\"5px\" stroke=\"gray\" >ALT + 6 REPOP 1st MARKER</text>]]\n    ind = ind + 1\n    svgT[ind] = [[<text x=\"20\" y=\"60\" fill=\"skyblue\" font-size=\"20\" font-family=\"Play\" stroke-width=\"5px\" stroke=\"gray\" >ALT + 7 ADD MANUAL WP</text>]]\n    ind = ind + 1\n    svgT[ind] = [[<text x=\"20\" y=\"80\" fill=\"skyblue\" font-size=\"20\" font-family=\"Play\" stroke-width=\"5px\" stroke=\"gray\" >ALT + 8 REMOVE LAST WP</text>]]    \n    ind = ind + 1\n    svgT[ind] = [[<text x=\"20\" y=\"100\" fill=\"skyblue\" font-size=\"20\" font-family=\"Play\" stroke-width=\"5px\" stroke=\"gray\" >ALT + 9 AUTO RECORD BY DIST.</text>]]\n    else\n    ind = ind + 1\n    svgT[ind] = [[<text x=\"20\" y=\"80\" fill=\"skyblue\" font-size=\"20\" font-family=\"Play\" stroke-width=\"5px\" stroke=\"gray\" >ALT + 9 START</text>]]\n    ind = ind + 1\n    svgT[ind] = [[<text x=\"20\" y=\"100\" fill=\"skyblue\" font-size=\"20\" font-family=\"Play\" stroke-width=\"5px\" stroke=\"gray\" >ALT + 0 RESUME</text>]]\n        \n        \n   -- ind = ind + 1\n   -- svgT[ind] = [[<text x=\"20\" y=\"100\" fill=\"skyblue\" font-size=\"20\" font-family=\"Play\" stroke-width=\"5px\" stroke=\"gray\" >ALT + 0 RESUME</text>]]\n    end\n        \n        \n    ind = ind + 1\n    svgT[ind] = [[<text x=\"290\" y=99.5% fill=\"skyblue\" font-size=\"14\"  font-family=\"Play\" stroke-width=\"2px\" stroke=\"gray\" >CTRL + BACKSPACE to EXIT</text>]]\n    \n    if fpsCount == true then \n        ind = ind + 1\n        svgT[ind] = [[<text x=1% y=2% fill=\"lime\" font-size=\"20\" text-anchor=\"start\" font-family=\"Indoscreen\">]]..fps..[[</text>]]\n    end\n    \n    local tSVG = concat(tSVG)\n    local SVG = concat(svgT)\n    \n    html = [[\n    <style>\n    svg {\n    position:absolute;\n    top:0px;\n    left:0px\n    }\n    </style>\n    </style>\n    <div style=\"left:20px; top:110px; position:absolute; width:100%; height:100%\">  \n    ]].. tSVG ..[[\n    </div>\n    \n    <div>\n    <svg viewBox=\"0 0 ]].. sw ..[[ ]].. sh ..[[\">\n    ]].. styles .. [[\n    ]].. mask .. [[\n    ]].. SVG ..[[\n    </svg>\n    </div>\n    ]]\n    \n    system.setScreen(html)\n    uCount = uCount + 1\n    \n    if finnished == true and button and emitter and button.isDown() == true then\n        emitter.send(emitterChan,serialize({name = playerName, bestTime = tTime}))\n    end\nend","filter":{"args":[],"signature":"onUpdate()","slotKey":"-4"},"key":"15"},{"code":"local concat = table.concat\n\nlocal function internalSerialize(table, tC, t)\n    t[tC] = \"{\"\n    tC = tC + 1\n    if #table == 0 then\n        local hasValue = false\n        for key, value in pairs(table) do\n            hasValue = true\n            local keyType = type(key)\n            if keyType == \"string\" then\n                t[tC] = key .. \"=\"\n            elseif keyType == \"number\" then\n                t[tC] = \"[\" .. key .. \"]=\"\n            elseif keyType == \"boolean\" then\n                t[tC] = \"[\" .. tostring(key) .. \"]=\"\n            else\n                t[tC] = \"notsupported=\"\n            end\n            tC = tC + 1\n\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = '\"' .. value .. '\"'\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        if hasValue then\n            tC = tC - 1\n        end\n    else\n        for i = 1, #table do\n            local value = table[i]\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = '\"' .. value .. '\"'\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        tC = tC - 1\n    end\n    t[tC] = \"}\"\n    return tC\nend\n\nfunction serialize(value)\n    local t = {}\n    local check = type(value)\n\n    if check == \"table\" then\n        internalSerialize(value, 1, t)\n    elseif check == \"string\" then\n        return '\"' .. value .. '\"'\n    elseif check == \"number\" then\n        return value\n    elseif check == \"boolean\" then\n        return tostring(value)\n    else\n        return '\"Not Supported\"'\n    end\n\n    return concat(t)\nend\n\nfunction deserialize(s)\n    return load(\"return \" .. s)()\nend","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"16"}],"methods":[],"events":[]}
