{"slots":{"0":{"name":"receiver","type":{"events":[],"methods":[]}},"1":{"name":"slot2","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"if message == \"syncstart\" and running == false then\n    chronoStartCode = system.getUtcTime() + 10\n    script.onStart()\nelse\nend\n\nsystem.print(\"SPEEDER chan/mess: \"..channel .. \" / \" ..message)\n\nif channel == tostring(player.getId()..\"R\") then\n    if message == \"upload\" and listening == false then\n        listening = true\n        emitter.send(tostring(player.getId())..\"S\",\"start upload\")\n        system.print(\"SPEEDER: starting download\")\n    elseif listening == true and message ~= \"upload\" and message ~= \"upload finished\" then\n        --system.print(\"SPEEDER: chunk received \"..message)\n        if previousUploadData ~= message then\n            uploadData = uploadData .. message\n            previousUploadData = uploadData\n            system.print(\"SPEEDER: chunk received \"..#uploadData)\n            \n        else\n            \n        end\n        emitter.send(tostring(player.getId())..\"S\",\"received\")\n        \n    elseif message == \"upload finished\" and listening == true then\n        system.print(\"SPEEDER final data: \"..#uploadData)\n        emitter.send(tostring(player.getId())..\"S\",\"end upload\")\n        local decodedData = deserialize(uploadData)\n        system.print(decodedData.circuitName)\n        system.print(decodedData.version)\n        --system.print(table.concat(decodedData.waypoints))\n        for i, v in ipairs(decodedData.waypoints) do \n            system.print(v)\n        end\n        local dbData = deserialize(DB.getStringValue(decodedData.circuitName))\n        if not dbData or dbData.version < decodedData.version then\n            system.print(\"Newer version of \"..decodedData.circuitName..\" dowloaded, erasing previous one\")\n            DB.setStringValue(decodedData.circuitName, uploadData)\n        end\n        --WP = convertWP(decodedData.waypoints)\n        listening = false\n        uploadData = \"\"\n        previousUploadData = nil\n        script.onStart()\n    end\nend","filter":{"args":[{"variable":"*"},{"variable":"*"}],"signature":"onReceived(channel,message)","slotKey":"0"},"key":"0"},{"code":"if initialised == false then\n    emitter.send(emitterChan,serialize({name = player.getName(), bestTime = tTime}))\nend","filter":{"args":[],"signature":"onPressed()","slotKey":"5"},"key":"1"},{"code":"system.print(system.getUtcTime())\n\n----------------------------------------------------------------------------------------------------\n-----------------------------------------------------------------------------------------------------\ncircuitName = \"Hadron Island Cup\" --export: circuit name\nversion = 1.0 --export: circuit version\nemitterChan = \"hadronRace\" --export: emitter communication channel for leader board\nchronoStartCode = 1666537200 -- export: race time code for synchronized start (starting date in seconds)\ndamageRepportFontHeight = 100 --export: AR damage repport font size\ntourEnd = 1 -- export: laps total number\nsetWaypoint = true --export: set default DU waypoints display\nARWaypoints = true --export: enable or disable AR waypoints display\nARPath = true --export: enable or disable AR path display\nARPathLength = 4 --export: number of waypoints for path to display\nscaleCurve = 0.0000015 --export: curve scale for waypoints display distance(the smaller the further waypoints will appear)\nconstructMask = true --export: virtual bounding box mask covering up waypoints\nbBoxScale = {0.9,1,0.7,1,1,0.7} --export: scale of the bBox for the mask{x front, y front, z front, x back, y back, z back}\nrecordingMode = false --export: activates admin mode for waypoints recording\nautoRecording = false -- ALT + F9\nautoRecordingdistance = 350\nrecordedWPPos = {}\nwpRadius = 30 --export: checkpoints are considered as a sphere in meter\nwpHeight = 5 --export: height of the center of checkpoint above recorded position\n-- ALT + 9 = auto recording by distance\n-- ALT + 8 = remove last waypoint\n-- ALT + 7 = add custom waypoint on player pos\n-- ALT + 6 = repop 1st waypoint marker\n\n\n-- set here under a custom list of waypoints\nwpPos = {}\n\n\n\ndammageAR = false -- export: AR dammage repport\n--system.setWaypoint(wpPos[1],true)\nsounds = {start = {\"Race_start.mp3\",2.8},\n          checkpoint = {\"Race_checkpoint.mp3\",0.8},\n          finish = {\"Race_finish.mp3\",7}}\n\n----------------------------------------------------------------------------------------------------\n-----------------------------------------------------------------------------------------------------\n\nsystem.print(\"Sync Board started\")\ncore = nil\nscreen = nil\nemitter = nil\nbutton = nil\nreceiver = nil\nDb = nil\nlocal function findConnectedSlots()\n    local slot = {}\n    for slotName in pairs(unit) do\n        slot = unit[slotName]\n         if type(slot)=='table' and unit[slotName].getClass ~= nil and slotName~='system' and slotName~='library' and slotName~='unit' and slotName~='export' then\n            --system.print(slot.getElementClass())\n            if slot.getClass() == \"CoreUnitDynamic\" then\n                core = slot\n                system.print(\"Core found\")\n            end\n            if slot.getClass() == \"ScreenUnit\" then\n                screen = slot\n                system.print(\"Screen found\")\n            end\n            if slot.getClass() == \"EmitterUnit\" then\n                emitter = slot\n                system.print(\"Emitter found\")\n            end    \n            if slot.getClass() == \"ManualButtonUnit\" then\n                button = slot\n                system.print(\"Button found\")\n            end\n            if slot.getClass() == \"ReceiverUnit\" then\n                receiver = slot\n                system.print(\"Receiver found\")\n            end\n            if slot.getClass() == \"DataBankUnit\" then\n                DB = slot\n                system.print(\"Databank found\")\n            end\n        end\n    end\nend\nfindConnectedSlots()\nif not core or not emitter or not receiver or not DB then system.print(\"Core/emitter/receiver/databank needs to be connected!\") unit.exit()end\n\nAtlas = require \"atlas\"\nHelios = {}\nfor k, v in pairs(Atlas[0]) do\n    Helios[k]={name = Atlas[0][k].name[1],\n                        center = Atlas[0][k].center,\n                        radius = Atlas[0][k].radius,\n                        id = Atlas[0][k].id,\n                        }\nend\nAtlas = nil\n\n--playerName = string.sub(player.getName(),1,8) -- shorter names string 8 letters\nplayerName = player.getName()\n\nfunction playSound(mp3)\n    system.playSound(sounds[mp3][1])\nend\n-----------Receiverchannel setup----------------\nreceiverChan = \"syncstart\" --export:Syncstart channel\nchannels = {receiverChan,tostring(player.getId())..\"R\"}\nif receiver then receiver.setChannelList(channels) end\n------------------------------------------------\n\nlocal cos, sin, max, min, sqrt, rad, match, toNum = math.cos, math.sin, math.max, math.min, math.sqrt, math.rad, string.match, tonumber\nlocal function convertToWorldCoordinates(posString)\n    local num        = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'\n    local posPattern = '::pos{' .. num .. ',' .. num .. ',' .. num .. ',' .. num ..  ',' .. num .. '}'\n    local systemId, bodyId, latitude, longitude, altitude = match(posString,posPattern)\n    systemId = toNum(systemId)\n    bodyId = toNum(bodyId)\n    latitude = toNum(latitude)\n    longitude = toNum(longitude)\n    altitude = toNum(altitude)+wpHeight\n    if toNum(bodyId) == 0 then\n        return latitude,longitude,altitude\n    end\n    latitude = 0.0174532925199 * max(min(latitude, 90), -90)\n    longitude = 0.0174532925199 * (longitude % 360)\n    local center, radius = Helios[bodyId].center, toNum(Helios[bodyId].radius)\n    local xproj = cos(latitude)\n    local px, py, pz = center[1]+(radius+altitude) * xproj*cos(longitude),\n    center[2]+(radius+altitude) * xproj*sin(longitude),\n    center[3]+(radius+altitude) * sin(latitude)\n    return px, py, pz\nend\n\nlocal convertWP = function(t) -- convert a table of pos\n    if type(t[1]) == \"string\" then \n        local newT = {}\n        local x,y,z = 0,0,0\n        for i, v in ipairs(t) do\n            x,y,z = convertToWorldCoordinates(v)\n            newT[i] = {x,y,z} \n        end\n        return newT\n     elseif type(t[1]) == \"table\" then\n        return t\n     end\nend\n\n\nelements = core.getElementIdList()\nallElements = {}\ndammagedElements = {}\nlocal ei = 0\nfor k, v in pairs(elements) do\n    local class = core.getElementDisplayNameById(v)\n    local data = system.getItem(core.getElementItemIdById(v))\n    ei = ei+1\n    allElements[ei] = {id = v, name = class,text = \"0\", health = core.getElementHitPointsById(v), maxHealth = core.getElementMaxHitPointsById(v), localPos = core.getElementPositionById(v), pos = {0,0,0}}\nend\n\nlocal bBoxSize = construct.getBoundingBoxSize()\nlocal bBx, bBy, bBz =  bBoxSize[1], bBoxSize[2], bBoxSize[3]\nlocal bBoxCenter = construct.getBoundingBoxCenter()\nlocal bBCx, bBCy, bBCz = bBoxCenter[1], bBoxCenter[2], bBoxCenter[3]\n\nlocalBb = {{bBCx-(bBx/2)*bBoxScale[1],bBCy+(bBy/2)*bBoxScale[2],bBCz+(bBz/2)*bBoxScale[3]},\n            {bBCx-(bBx/2)*bBoxScale[4],bBCy-(bBy/2)*bBoxScale[5],bBCz-(bBz/2)*bBoxScale[6]},\n            {bBCx+(bBx/2)*bBoxScale[4],bBCy-(bBy/2)*bBoxScale[5],bBCz-(bBz/2)*bBoxScale[6]},\n            {bBCx+(bBx/2)*bBoxScale[1],bBCy+(bBy/2)*bBoxScale[2],bBCz+(bBz/2)*bBoxScale[3]},\n            {bBCx-(bBx/2)*bBoxScale[1],bBCy+(bBy/2)*bBoxScale[2],bBCz+(bBz/2)*bBoxScale[3]}\n            }\nworldBb = {}\nWP = {}\n\nlistening = false\nuploadData = \"\"\npreviousUploadData = nil\n\nscript = {\n    onStart = function()\n        local dbKeys = DB.getKeyList()\n        system.print(\"--------------------------\")\n        system.print(\"Tracks found on Databank:\")\n        for k, v in pairs(dbKeys) do\n            system.print(\"- \"..v)\n        end\n        system.print(\"--------------------------\")\n        if uploadData == \"\" and listening == false then\n            local decodedData = deserialize(DB.getStringValue(circuitName))\n            if decodedData and decodedData.waypoints then\n                circuitName = decodedData.circuitName or \"No Name\"\n                version = decodedData.version or 1.0\n                wpRadius = decodedData.wpRadius or wpRadius\n                tourEnd = decodedData.tourEnd or tourEnd\n                wpPos = decodedData.waypoints\n                WP = convertWP(wpPos) -- convert wpPos strings into world coordinates\n                --system.setWaypoint(wpPos[1],true)\n                system.setWaypoint(\"::pos{0,0,\"..WP[1][1]..\",\"..WP[1][2]..\",\"..WP[1][3]..\"}\",true)\n                system.print(\"Databank circuit loaded: \"..circuitName)\n                system.print(\"Databank waypoints loaded: \"..#WP)\n                system.print(\"To change the circuit, change circuitName variable in external parameters!\")\n            else\n                if #recordedWPPos ~= 0 and recordingMode == true then\n                    WP = convertWP(recordedWPPos)\n                    system.setWaypoint(recordedWPPos[1],true)\n                    system.print(\"Custom reccorded waypoints loaded: \"..#WP)\n                elseif #WP ~= 0 then\n                    WP = convertWP(wpPos) -- convert wpPos strings into world coordinates\n                    system.setWaypoint(wpPos[1],true)\n                    system.print(\"Hardcoded waypoints loaded \"..#WP)\n                end\n            end\n        end\n        system.showScreen(1)\n        fps = 0\n        uCount = 0\n        fillAnim = 1\n        initialised = false\n        running = false\n        finnished = false\n        playerRecap = {}\n        playerRecap.chronoTours = {}\n        playerRecap.waypoint = 0\n        playerRecap.bestTour = 0\n        tTime = 99999\n        remainingWP = WP\n        local startDelay = chronoStartCode < system.getUtcTime() and system.getUtcTime() + chronoStartCode or chronoStartCode - system.getUtcTime()\n        --chronoStartCode = chronoStartCode - system.getUtcTime()\n        --system.print(chronoStartCode)\n        unit.setTimer(\"fps\",1)\n        unit.setTimer(\"startdelay\",startDelay)\n        system.setScreen(\"\")\n        --system.setWaypoint(wpPos[1],true)\n        system.print(\"Script initialised succesfully!\")\n        if setWaypoint == true then\n            unit.setTimer(\"WP\",0.01)\n        end\n        listening = false\n        --emitter.send(emitterChan,serialize({construct = {id = construct.getId(), name = construct.getName()}, player = {id = player.getId(), name = player.getName()}, totalTime = 0, lap = 1}))\n    end,\n\n    onStop = function()\n        system.print(\"Thank you for playing on \"..circuitName..\", see you soon!\")\n    end,\n\n    luaInput = function(text)\n        if text == \"reset race\" then\n            chronoStartCode = system.getUtcTime() + 10\n            script.onStart()\n        elseif string.sub(text,1,6)  == \"remove\" then\n            if DB.hasKey(string.sub(text,8,-1)) then\n                DB.clearValue(string.sub(text,8,-1))\n                system.print(\"Track \"..string.sub(text,8,-1)..\" has been deleted\")\n            end\n        elseif text == \"force start\" then\n            chronoStartCode = system.getUtcTime() + 10\n            script.onStart()\n        elseif text == \"reset recording\" then\n            recordedWPPos = {}\n        elseif text == \"print to screen\" then\n            local data = \"{\"\n            for i, v in ipairs(recordedWPPos) do\n                data = data ..'\"'.. v ..'\",'\n            end\n            data = data .. \"}\"\n            if screen ~= nil then \n                screen.setHTML(data)\n            end\n        elseif text == \"reset all\" then\n            DB.clear()\n            unit.exit()\n        end\n    end,\n}\nscript.onStart()\n\n","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"2"},{"code":"fps = uCount\nuCount = 0\nif finnished == true then\n    system.print(serialize({name = playerName, bestTime = tTime}))\n    emitter.send(emitterChan,serialize({name = playerName, bestTime = tTime}))\nend","filter":{"args":[{"value":"fps"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"3"},{"code":"initialised = true\nplayerRecap.chronoTours[1] = {system.getUtcTime(),0}\nplaySound(\"start\")\nunit.stopTimer(\"startdelay\")","filter":{"args":[{"value":"startdelay"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"4"},{"code":"script.onStop()","filter":{"args":[],"signature":"onStop()","slotKey":"-1"},"key":"5"},{"code":"if waypointUp == true then\n    --system.print(\"waypoint up\")\n    system.setWaypoint(\"::pos{0,0,\"..remainingWP[1][1]..\",\"..remainingWP[1][2]..\",\"..remainingWP[1][3]..\"}\",true)\n    waypointUp = false\nend\n","filter":{"args":[{"value":"WP"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"6"},{"code":"local sgt = system.getUtcTime()\nlocal sqrt, tan, rad, format, concat, floor = math.sqrt, math.tan, math.rad, string.format, table.concat, math.floor\nlocal sw = system.getScreenWidth()\nlocal sh = system.getScreenHeight()\nlocal vFov = system.getCameraVerticalFov()\nlocal near = 0.1\nlocal far = 100000000.0\nlocal aspectRatio = sh/sw\nlocal tanFov = 1.0/tan(rad(vFov)*0.5)\nlocal field = -far/(far-near)\nlocal af = aspectRatio*tanFov\nlocal nq = near*field\n\nlocal camWP = system.getCameraWorldPos()\nlocal camWPx, camWPy, camWPz = camWP[1], camWP[2], camWP[3]\nlocal camWF = system.getCameraWorldForward()\nlocal camWFx, camWFy, camWFz = camWF[1], camWF[2], camWF[3]\nlocal camWR = system.getCameraWorldRight()\nlocal camWRx, camWRy, camWRz = camWR[1], camWR[2], camWR[3]\nlocal camWU = system.getCameraWorldUp()\nlocal camWUx, camWUy, camWUz = camWU[1], camWU[2], camWU[3]\n\nlocal cWP = construct.getWorldPosition()\nlocal cWPx, cWPy, cWPz = cWP[1], cWP[2], cWP[3]\nlocal cWOU = construct.getWorldOrientationUp()\nlocal cWOUx, cWOUy, cWOUz = cWOU[1], cWOU[2], cWOU[3]\nlocal cWOF = construct.getWorldOrientationForward()\nlocal cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]\nlocal cWOR = construct.getWorldOrientationRight()\nlocal cWORx, cWORy, cWORz = cWOR[1], cWOR[2], cWOR[3]\nlocal mPP = player.getPosition()\nlocal mPPx, mPPy = mPP[1], mPP[2]\nlocal cAV = construct.getWorldVelocity()\nlocal cAVx, cAVy, cAVz = cAV[1], cAV[2], cAV[3]\nlocal xyzSpeedMPS = sqrt(cAVx^2+cAVy^2+cAVz^2)\n\nlocal posX, posY, posZ = 0, 0, 0\nlocal vx, vy, vz = 0, 0, 0\nlocal sx, sy, sz = 0, 0, 0\nlocal sPX, sPY = 0\nlocal dist = 0\n\nlocal function projection2D()\n    vx = posX * camWRx + posY * camWRy + posZ * camWRz\n    vy = posX * camWFx + posY * camWFy + posZ * camWFz\n    vz = posX * camWUx + posY * camWUy + posZ * camWUz\n    sx = (af * vx)/vy\n    sy = ( -tanFov * vz)/vy\n    sz = ( -field * vy + nq)/vy\n    sPX, sPY = (sx+1)*sw*0.5, (sy+1)*sh*0.5 -- screen pos X Y\n    dist = sqrt(posX*posX + posY*posY + posZ*posZ) -- distance from camera to pos\nend\n\nlocal styles = [[\n<style>\n.markers {text-anchor: middle; font-family: Play; alignment-baseline: middle; fill: white;}\n.counter {text-anchor: middle; font-family: Play; alignment-baseline: middle; fill: red;}\n.hud {text-anchor: start; font-family: Play; alignment-baseline: middle; stroke-width: 2; fill: red;}\n.repport {text-anchor: middle; font-family: Play; alignment-baseline: middle; fill: orange;}\n.repportRed {text-anchor: middle; font-family: Play; alignment-baseline: middle; fill: red;}\n</style>]]\n\nlocal mask = \"\"\nif system.isFirstPerson() ~= 1 and constructMask == true then\n    mask = mask..[[<clipPath id=\"bBox\"><polyline points=\"0,0 ]]..sw..[[,0 ]]..sw..[[,]]..sh..[[ 0,]]..sh..[[ 0,0 ]]\n    for i, v in ipairs(worldBb) do\n        posX = v[1] - camWPx\n        posY = v[2] - camWPy\n        posZ = v[3] - camWPz\n        projection2D()\n        mask = mask .. format(\"%0.1f,%0.1f \",sPX,sPY)\n    end\n    mask = mask .. [[\"/></clipPath>]]\nend\n    \nlocal style = \"\"\nlocal svgT = {}\nlocal ind = 0\nlocal text = \"\"\n\nif dammageAR == true then\nfor i, v in ipairs(dammagedElements) do\n    style = \"repport\"\n    posX = v.pos[1] - camWPx\n    posY = v.pos[2] - camWPy\n    posZ = v.pos[3] - camWPz\n    projection2D()\n    if sz < 1 and sPX > 0 and sPX < sw and sPY > 0  and sPY < sh then\n        text = v.text\n        if tonumber(v.text) == 0 then style = \"repportRed\" text = v.name end\n        ind = ind +1\n        svgT[ind] = format([[<text x=\"%.1f\" y=\"%.1f\" class=\"%s\" font-size=\"%.1f\">%s%%</text>]], \n            sPX,sPY,style,1 / dist * damageRepportFontHeight,text\n        )\n    end\nend\nend\nlocal ctn = #playerRecap.chronoTours or 0\nlocal wpn = #remainingWP ~= 0 and #remainingWP or #WP\nif running == true and recordingMode == false then\n    if ARPath == true then\n        --cWPx, cWPy, cWPz cWOFx, cWOFy, cWOFz\n        posX = cWPx+cWOFx*5 - camWPx\n        posY = cWPy+cWOFy*5 - camWPy\n        posZ = cWPz+cWOFz*5 - camWPz\n        projection2D()\n        ind = ind +1\n        svgT[ind] =  format([[<polyline fill=\"none\" stroke=\"yellow\" stroke-width=\"2\" stroke-opacity=\"0.5\" points=\"%.1f,%.1f ]], sPX, sPY)\n        for i=1, ARPathLength do\n            local nextWP = i < wpn and remainingWP[i] or WP[i]\n            posX = nextWP[1] - camWPx\n            posY = nextWP[2] - camWPy\n            posZ = nextWP[3] - camWPz\n            projection2D()\n            if sz < 1 and sPX > -sw and sPX < 2*sw and sPY > -sh  and sPY < 2*sh then\n                ind = ind +1\n                svgT[ind] =  format([[%.1f,%.1f ]], sPX, sPY)\n            end\n        end\n        ind = ind +1\n        svgT[ind] =  [[\"/>]]\n    end\n    if ARWaypoints == true then\n        fillAnim = fillAnim > 0.85 and fillAnim - 0.005 or 1\n        local sizeScale = 1\n        for i=wpn, 1, -1 do\n            local v = remainingWP[i]\n            posX = v[1] - camWPx\n            posY = v[2] - camWPy\n            posZ = v[3] - camWPz\n            projection2D()\n            sizeScale = -scaleCurve*v.dist^2 + 1\n            sizeScale = sizeScale > 0 and sizeScale or 0\n            if sz < 1 and sPX > -sw and sPX < 2*sw and sPY > -sh  and sPY < 2*sh and sizeScale > 0 then\n                local h = 1 / dist * wpRadius * 1000\n                local fcolor = ctn == tourEnd and playerRecap.waypoint == wpn and i == 1 and \"orange\" or i == 1 and \"chartreuse\" or \"skyblue\"\n                --if  then fcolor = \"gold\" end\n                ind = ind +1\n                svgT[ind] = format([[<style>\n                .waypoint%s {text-anchor: middle; stroke: %s; stroke-width: %.1f}\n                </style>]],\n                i, \"GreenYellow\", 1 / dist * 200)\n                ..format([[<radialGradient id=\"radial\" cx=\"%.1f\" cy=\"%.1f\" r=\"%.1f\"\n                gradientUnits=\"userSpaceOnUse\">\n                <stop  offset=\"%.2f\" style=\"stop-color:%s; stop-opacity:0.05\"/>\n                <stop  offset=\"1\" style=\"stop-color:%s\"; stop-opacity:0/>\n                </radialGradient>]],\n                sPX, sPY,  h*sizeScale, fillAnim, \"black\", fcolor)\n                ..format([[<circle cx=\"%.1f\" cy=\"%.1f\" r=\"%.1f\" class=\"%s\" fill=\"url(#radial)\" clip-path=\"url(#bBox)\"/>]], \n                sPX, sPY,  h*sizeScale, \"waypoint\"..i)\n                if fcolor == \"orange\" then break end\n            end\n        end\n    end\nelseif recordingMode == true then\n    wpn = #WP\n    for i=wpn, 1, -1 do\n        local v = WP[i]\n        posX = v[1] - camWPx\n        posY = v[2] - camWPy\n        posZ = v[3] - camWPz\n        projection2D()\n        if sz < 1 and sPX > -sw and sPX < 2*sw and sPY > -sh  and sPY < 2*sh then\n            local h = 1 / dist * 2000\n            ind = ind + 1\n            svgT[ind] = format([[<text x=\"%.1f\" y=\"%.1f\" class=\"markers\" font-size=\"%.1f\" clip-path=\"url(#bBox)\">%s</text>]],\n                sPX, sPY, h, i)\n        end\n        if i == wpn - 50 then break end\n    end\nend\n\n\n--SVG = SVG .. [[<text x=\"20\" y=\"20\" class=\"hud\" font-size=\"20\" >AR Ship Info - by Jeronimo 2022</text>]] \n--SVG = SVG .. [[<text x=\"20\" y=\"40\" class=\"hud\" font-size=\"20\" >FPS: ]].. fps ..[[</text>]] \n--SVG = SVG .. [[<text x=\"20\" y=\"60\" class=\"hud\" font-size=\"20\" >AR points displayed: ]].. ind ..[[</text>]]\n\nlocal function SecondsToClock(seconds)\n    local seconds = tonumber(seconds)\n    local miliSec = seconds - floor(seconds) \n    if seconds <= 0 then --or floor(seconds/3600) > 24 \n        return \"00min : 00sec\"\n    else\n        local hours = format(\"%02.f\", floor(seconds/3600))\n        local mins = format(\"%02.f\", floor(seconds/60 - (hours*60)))\n        local secs = format(\"%02.f\", floor(seconds - hours*3600 - mins *60))\n        return format(\"%.0fmin : %.0fsec : %0.fms\", hours*60+mins, secs, miliSec*1000)\n    end\nend  \n\nlocal tSVG = {}\nlocal tind = 0\nlocal tLines = 5\nlocal gAT = running == true and system.getUtcTime() or ctn ~= 0 and playerRecap.chronoTours[ctn][2] or system.getUtcTime()\n\ntind = tind +1\ntSVG[tind] = [[<table height=]].. 15/ctn+tLines ..[[% border=\"1\" cellpadding=\"5\">\n<tr>\n<td height=]].. 100/ctn+tLines ..[[% width=100% align=\"left\" valign=\"center\">\n<p style=\"font-size: 1.25em; color:skyblue; font-family:Play; \">\n]].. circuitName..\" v\"..version ..[[\n</p>\n</td>\n</tr>]]\n\ntind = tind +1\ntSVG[tind] = [[\n<tr>\n<td height=]].. 100/ctn+tLines ..[[% width=100% align=\"left\" valign=\"center\">\n<p style=\"font-size: 1em; color:white; font-family:Play; \">\nWaypoint: ]].. playerRecap.waypoint..\"/\".. wpn ..[[\n</p>\n</td>\n</tr>]]\n\ntind = tind +1\ntSVG[tind] = [[\n<tr>\n<td height=]].. 100/ctn+tLines ..[[% width=100% align=\"left\" valign=\"center\">\n<p style=\"font-size: 1em; color:white; font-family:Play; \">\nLap: ]].. ctn ..\"/\".. tourEnd ..[[\n</p>\n</td>\n</tr>]]\n\nfor i, v in ipairs(playerRecap.chronoTours) do\n    local timeText = i < ctn and SecondsToClock(v[2]-v[1]) or SecondsToClock(gAT-v[1]) \n    tind = tind +1\n    tSVG[tind] = [[<tr>\n    <td height=]].. 100/ctn+tLines ..[[% width=100% align=\"left\" valign=\"center\">\n    <p style=\"font-size: 1.1em; color:red; font-family:Play;\">\n    Lap time ]].. i ..[[: ]].. timeText ..[[\n    </p>\n    </td>\n    </tr>]]     \nend\n\ntind = tind +1\ntSVG[tind] = [[\n<tr>\n<td height=]].. 100/ctn+tLines ..[[% width=100% align=\"left\" valign=\"center\">\n<p style=\"font-size: 1em; color:white; font-family:Play; \">\nBest Time: ]].. SecondsToClock(playerRecap.bestTour) ..[[\n</p>\n</td>\n</tr>]]\n\nif ctn ~= 0 then\n    tind = tind +1\n    tSVG[tind] = [[\n    <tr>\n    <td height=]].. 100/ctn+tLines ..[[% width=100% align=\"left\" valign=\"center\">\n    <p style=\"font-size: 1em; color:white; font-family:Play; \">\n    Total Time: ]].. SecondsToClock(gAT-playerRecap.chronoTours[1][1]) ..[[\n    </p>\n    </td>\n    </tr>]]\nend\n\ntind = tind +1\ntSVG[tind] = \"</table>\"\n\ngAT = system.getUtcTime()\nif chronoStartCode - gAT > 0 then\n    ind = ind +1\n    svgT[ind] = format([[<text x=\"%.1f\" y=\"%.1f\" class=\"counter\" font-size=\"3em\">%s starts in: %s</text>]],\n                 sw/2, sh/2, circuitName, SecondsToClock(chronoStartCode - gAT))\n    --system.print(chronoStartCode - gAT)\nend\n\ntSVG = concat(tSVG)\nlocal SVG = concat(svgT)\n\nposX = cWOFx*1000000000000 - camWPx\nposY = cWOFy*1000000000000 - camWPy\nposZ = cWOFz*1000000000000 - camWPz\nprojection2D()\nSVG = SVG..format([[<text x=\"%.1f\" y=\"%.1f\" font-size=\"20\" text-anchor=\"middle\" font-family=\"play\" alignment-baseline=\"middle\" fill=\"white\">╬</text>]],\n        sPX, sPY)\nif xyzSpeedMPS > 5 then\n    posX = (cAVx)*1000000000000 - camWPx\n    posY = (cAVy)*1000000000000 - camWPy\n    posZ = (cAVz)*1000000000000 - camWPz\n    projection2D()\nend\nSVG = SVG..format([[<text x=\"%.1f\" y=\"%.1f\" font-size=\"20\" text-anchor=\"middle\" font-family=\"play\" alignment-baseline=\"middle\" fill=\"chartreuse\">┼</text>]],\n    sPX, sPY)\n\n\nhtml = [[\n<style>\nsvg {\nposition:absolute;\ntop:0px;\nleft:0px\n}\n</style>\n</style>\n<div style=\"left:20px; top:30%; position:absolute; width:100%; height:100%\">  \n]].. tSVG ..[[\n</div>\n<div>\n<svg viewBox=\"0 0 ]].. sw ..[[ ]].. sh ..[[\">\n]].. styles .. [[\n]].. mask .. [[\n]].. SVG ..[[\n</svg>\n</div>\n]]\n\nsystem.setScreen(html)\nuCount = uCount + 1\n\nif finnished == true and button and emitter and button.isDown() == true then\n    emitter.send(emitterChan,serialize({name = playerName, bestTime = tTime}))\nend","filter":{"args":[],"signature":"onUpdate()","slotKey":"-4"},"key":"7"},{"code":"local format,cos, sin, max, min, sqrt, rad, match, toNum = string.format, math.cos, math.sin, math.max, math.min, math.sqrt, math.rad, string.match, tonumber\nlocal cWP = construct.getWorldPosition()\nlocal cWPx, cWPy, cWPz = cWP[1], cWP[2], cWP[3]\nlocal cWOU = construct.getWorldOrientationUp()\nlocal cWOUx, cWOUy, cWOUz = cWOU[1], cWOU[2], cWOU[3]\nlocal cWOF = construct.getWorldOrientationForward()\nlocal cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]\nlocal cWOR = construct.getWorldOrientationRight()\nlocal cWORx, cWORy, cWORz = cWOR[1], cWOR[2], cWOR[3]\n\nlocal function vectorLen(x,y,z)\n    return sqrt(x * x + y * y + z * z)\nend\n\nif initialised == true and recordingMode == false then\n    local function tableShift(tbl, amount)\n        local t = {}\n        local n = #tbl\n        local i\n        for k,v in ipairs(tbl) do\n            i = k + amount > 0 and k + amount or n\n            if i <= n then\n                t[i] = v\n            else\n                t[i-n] = v\n            end\n        end\n        return t\n    end\n    \n    local x,y,z = 0,0,0\n    local function local2World(vx,vy,vz)\n        x = vx * cWORx + vy * cWOFx + vz * cWOUx + cWPx\n        y = vx * cWORy + vy * cWOFy + vz * cWOUy + cWPy\n        z = vx * cWORz + vy * cWOFz + vz * cWOUz + cWPz\n        return x,y,z\n    end\n\n    local vx,vy,vz = 0,0,0\n    local health = 100\n    local dind = 0\n    dammagedElements = {}\n    for i, v in ipairs(allElements) do\n        health = (core.getElementHitPointsById(v.id)/v.maxHealth)*100 or 0\n        --system.print(health)\n        if health < 99.9 then\n            dind = dind + 1\n            dammagedElements[dind] = {}\n            vx,vy,vz = local2World(v.localPos[1], v.localPos[2], v.localPos[3])\n            dammagedElements[dind].pos = {vx,vy,vz}\n            dammagedElements[dind].text = format(\"%.1f\",health)\n        end\n    end\n\n    for i, v in ipairs(localBb) do\n        vx,vy,vz = local2World(v[1], v[2], v[3])\n        worldBb[i] = {vx,vy,vz}\n    end\n    \n    \n    local gAT = system.getUtcTime() --system.print(gAT)\n    local tl = #remainingWP\n    local ctn = #playerRecap.chronoTours\n    local chrono = 0\n    \n    local wpDist = vectorLen(remainingWP[1][1]-cWPx,remainingWP[1][2]-cWPy,remainingWP[1][3]-cWPz)\n    if wpDist < wpRadius then\n        playerRecap.waypoint = playerRecap.waypoint + 1 \n        playSound(\"checkpoint\")\n        if playerRecap.waypoint > tl then \n            if ctn + 1 > tourEnd then\n                playSound(\"finish\")\n                playerRecap.chronoTours[ctn][2] = gAT\n                playerRecap.waypoint = 0\n                initialised = false\n                running = false\n                finnished = true\n                tTime = gAT-playerRecap.chronoTours[1][1]--system.getUtcTime()-playerRecap.chronoTours[1][1]\n                if emitter then\n                    emitter.send(emitterChan,serialize({name = playerName, bestTime = tTime}))\n                end\n            else\n                playerRecap.waypoint = 1\n                playerRecap.chronoTours[ctn][2] = gAT\n                playerRecap.chronoTours[ctn+1] = {gAT,0}    \n            end\n        --emitter.send(emitterChan,serialize({construct = {id = construct.getId(), name = construct.getName()}, player = {id = player.getId(), name = player.getName()}, totalTime = system.getUtcTime()-playerRecap.chronoTours[1][1], lap = #playerRecap.chronoTours})) \n        end\n        waypointUp = true\n        --system.setWaypoint(wpPos[playerRecap.waypoint+1],true)\n        remainingWP = tableShift(remainingWP, -1)\n    end\n\n    \n    local v2x,v2y,v2z = 0,0,0\n    for i, v in ipairs(remainingWP) do\n        vx,vy,vz = v[1], v[2], v[3]\n        if i == 1 then \n            wpDist = vectorLen(vx-cWPx,vy-cWPy,vz-cWPz)\n        else \n            if i < tl then\n                v2x,v2y,v2z = remainingWP[i+1][1], remainingWP[i+1][2], remainingWP[i+1][3]\n                wpDist = wpDist + vectorLen(vx-v2x,vy-v2y,vz-v2z)\n            else \n                v2x,v2y,v2z = remainingWP[1][1], remainingWP[1][2], remainingWP[1][3]\n                wpDist = wpDist + vectorLen(vx-v2x,vy-v2y,vz-v2z)\n            end\n        end\n        remainingWP[i].dist = wpDist\n    end\n\n    --table.sort(WP, function(a,b)return a.dist<b.dist end) --v[2]-v[1]\n    local max = math.huge\n    local min = 0\n    for i, v in ipairs(playerRecap.chronoTours) do\n        min = v[2]-v[1]\n        if i ~= cpn and min < max then\n            playerRecap.bestTour = min\n            max = min\n        end\n    end\n    running = true\n        \nelse \n    if recordingMode == true then\n        local function convertToWorldCoordinates(posString)\n            local num        = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'\n            local posPattern = '::pos{' .. num .. ',' .. num .. ',' .. num .. ',' .. num ..  ',' .. num .. '}'\n            local systemId, bodyId, latitude, longitude, altitude = match(posString,posPattern)\n            systemId = toNum(systemId)\n            bodyId = toNum(bodyId)\n            latitude = toNum(latitude)\n            longitude = toNum(longitude)\n            altitude = toNum(altitude)\n            if toNum(bodyId) == 0 then\n                return latitude,longitude,altitude\n            end\n            latitude = 0.0174532925199 * max(min(latitude, 90), -90)\n            longitude = 0.0174532925199 * (longitude % 360)\n            local center, radius = Helios[bodyId].center, toNum(Helios[bodyId].radius)\n            local xproj = cos(latitude)\n            local px, py, pz = center[1]+(radius+altitude) * xproj*cos(longitude),\n            center[2]+(radius+altitude) * xproj*sin(longitude),\n            center[3]+(radius+altitude) * sin(latitude)\n            return px, py, pz\n        end\n\n        local convertWP = function(t) -- convert a table of pos\n            local newT = {}\n            local x,y,z = 0,0,0\n            for i, v in ipairs(t) do\n                x,y,z = convertToWorldCoordinates(v)\n                newT[i] = {x,y,z} \n            end\n            return newT\n        end\n\n        local rx, ry, rz = cWPx, cWPy, cWPz\n        if #recordedWPPos ~= 0 then rx, ry, rz = convertToWorldCoordinates(recordedWPPos[#recordedWPPos])end\n        \n        local lastDist = vectorLen(rx-cWPx, ry-cWPy, rz-cWPz)\n        \n        if autoRecording == true and lastDist > autoRecordingdistance then\n            recordedWPPos[#recordedWPPos+1] = system.getWaypointFromPlayerPos()\n            --system.setWaypoint(system.getWaypointFromPlayerPos(),true)\n            system.print(\"auto waypoint added\")\n        end\n        WP = convertWP(recordedWPPos)\n    else\n        running = false\n    end\nend\n\n--playerRecap = {}\n--playerRecap.chronoStart = system.getArkTime()\n--playerRecap.chronoTours = {system.getArkTime()}\n--playerRecap.waypoint = 0\n--playerRecap.bestTour = 0\n--remainingWP = WP","filter":{"args":[],"signature":"onFlush()","slotKey":"-4"},"key":"8"},{"code":"script.luaInput(text)","filter":{"args":[{"variable":"*"}],"signature":"onInputText(text)","slotKey":"-4"},"key":"9"},{"code":"if recordingMode == true then\n    autoRecording = not autoRecording\n    if autoRecording == true then\n        system.print(\"recording\")\n        recordedWPPos[#recordedWPPos+1] = system.getWaypointFromPlayerPos()\n        system.setWaypoint(system.getWaypointFromPlayerPos(),true)\n    elseif autoRecording == false then\n        system.print(\"stoped recording\")\n        local data = \"{\"\n        for i, v in ipairs(recordedWPPos) do\n            data = data ..'\"'.. v ..'\",'\n        end\n        data = data .. \"}\"\n        if screen ~= nil then \n            screen.setHTML(data)\n        end\n    end\nelseif recordingMode == false and finnished == true and emitter then\n    system.print(serialize({name = playerName, bestTime = tTime}))\n    emitter.send(emitterChan,serialize({name = playerName, bestTime = tTime}))\nelseif recordingMode == false and finnished == false and emitter then\n    chronoStartCode = system.getUtcTime() + 10\n    script.onStart()\nend\n","filter":{"args":[{"value":"option9"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"10"},{"code":"if recordingMode == true then\n    system.print(\"last waypoint deleted\")\n    recordedWPPos[#recordedWPPos] = nil\n    --system.setWaypoint(recordedWPPos[#recordedWPPos],true)\nend","filter":{"args":[{"value":"option8"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"11"},{"code":"\nrecordedWPPos[#recordedWPPos+1] = system.getWaypointFromPlayerPos()\n--system.setWaypoint(system.getWaypointFromPlayerPos(),true)\nsystem.print(\"added custom waypoints: \"..#recordedWPPos)","filter":{"args":[{"value":"option7"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"12"},{"code":"if recordingMode == true then\n    system.setWaypoint(recordedWPPos[1],true)\n    system.print(\"recording\")\nend","filter":{"args":[{"value":"option6"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"13"},{"code":"local concat = table.concat\n\nlocal function internalSerialize(table, tC, t)\n    t[tC] = \"{\"\n    tC = tC + 1\n    if #table == 0 then\n        local hasValue = false\n        for key, value in pairs(table) do\n            hasValue = true\n            local keyType = type(key)\n            if keyType == \"string\" then\n                t[tC] = key .. \"=\"\n            elseif keyType == \"number\" then\n                t[tC] = \"[\" .. key .. \"]=\"\n            elseif keyType == \"boolean\" then\n                t[tC] = \"[\" .. tostring(key) .. \"]=\"\n            else\n                t[tC] = \"notsupported=\"\n            end\n            tC = tC + 1\n\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = '\"' .. value .. '\"'\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        if hasValue then\n            tC = tC - 1\n        end\n    else\n        for i = 1, #table do\n            local value = table[i]\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = '\"' .. value .. '\"'\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        tC = tC - 1\n    end\n    t[tC] = \"}\"\n    return tC\nend\n\nfunction serialize(value)\n    local t = {}\n    local check = type(value)\n\n    if check == \"table\" then\n        internalSerialize(value, 1, t)\n    elseif check == \"string\" then\n        return '\"' .. value .. '\"'\n    elseif check == \"number\" then\n        return value\n    elseif check == \"boolean\" then\n        return tostring(value)\n    else\n        return '\"Not Supported\"'\n    end\n\n    return concat(t)\nend\n\nfunction deserialize(s)\n    return load(\"return \" .. s)()\nend","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"14"}],"methods":[],"events":[]}
